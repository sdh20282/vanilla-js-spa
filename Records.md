### sdh20282's SPA Framework 기록

---
### 24.01.07
프로젝트 초기 설정 및 SPA 라우터 구현
- express 활용
  - 기존에 클라이언트 사이드에서 해당 작업이 전부 이루어지도록 구현한 경험이 있음
  - 클라이언트 사이드에서만 처리할 경우 새로고침이나 url 직접 조작 시 이러한 부분을 처리해주지 못함 -> 브라우저에서는 해당 url로 get 메서드를 날려버리기 때문
  - 따라서 간단한 서버에서 미들웨어를 통해 이러한 작업을 처리
- a 태그일 경우에만 라우팅 시도
  - 기존 경험에서는 라우팅을 위한 함수를 작성하고, a 태그를 사용할 때 a 태그의 동작을 막고, 해당 함수를 호출
  - 은근히 불편하다고 판단하여 방식 변경, 이벤트 버블링을 통해 a 태그일 경우에만 시도

---
### 24.01.08
라우팅 조건 변경
- 데이터 속성이 지정되어 있을 경우에만 라우팅 시도
  - a 태그일 경우에 모두 라우팅을 시도할 경우 외부 링크로 이동해야 하는 경우에도 막힘
  - 기존의 방법을 유지하며 외부 링크를 위한 a 태그에는 버블링을 막아주어야 함, 관리하기 까다롭다고 생각
  - data-link 속성이 존재하는 경우에만 라우팅 시도

---
### 24.01.11
router에서 lazy loading 구현
- 페이지 로딩하는 부분에서 구현
  - 초기 페이지 로딩 시 네트워크 응답 완료 시간 40-50ms -> 30-40ms로 감소 및 모든 페이지를 받아오지 않는 것 확인

---
### 24.01.12
router object로 최적화
- 경로를 array -> object로 변경

---
### 24.01.14
router 변경
- router를 function -> class로 변경
  - routes를 router.js 파일 내부가 아닌 index.js에서 받도록 하여 좀 더 관리하기 용이하게 하고자 함
  - 해당 과정에서 initRouter 함수는 외부에서 동작시킬 필요가 없으므로 위치 변경

---
### 24.01.17
reactivity 구현
- Proxy를 이용하여 reactivity 구현
  - Proxy와 Object.defineProperty 중 Proxy 선택
  - 역할은 거의 비슷하지만 Proxy가 조금 더 빠르고 가벼움
  - constructor가 실행된 이후 state에 Proxy를 씌워야 정상 동작함

---
### 24.01.18
mutable reactivity 구현
- Proxy를 이용하여 mutable reactivity 구현
  - array에서 원소를 추가, 삭제하거나
  - object에서 프로퍼티를 수정할 경우에는
  - 두 경우 모두 call by reference이기 때문에 get이 호출
  - 따라서 getter를 재정의하여 target의 타입이 null이 아니고, object일 경우에는 새로운 Proxy를 씌워 반환하여 mutable을 유지

---
### 24.01.24 ~ 23.01.26
component 구현
- shadow dom을 활용한 컴포넌트 구현 및 테스트
  - shadow dom은 기존 dom과 분리되어 스타일, 스크립트 등이 관리되고, 이러한 점은 컴포넌트에서도 유사하게 활용된다고 생각함
  - props 전달 확인
- shadow dom을 선택한 이유
  - shadow dom의 장점과 단점
    - 스타일과 스크립트가 전역 범위에 영향을 주지 않으므로, 컴포넌트 간의 충돌을 피할 수 있음
    - 유지보수와 전체적인 성능 향상에 긍정적인 영향을 미칠 수 있음
  - shadow dom의 단점
    - Shadow DOM을 사용하면, DOM 트리에 추가적인 레이어가 생기고, 이는 이는 브라우저가 처리해야 할 작업을 늘림, 복잡한 어플리케이션에서는 성능에 악형향을 줄 수 있음
      - 각 컴포넌트에 대해 별도의 DOM 트리가 생성되고, 이 DOM 트리는 메인 DOM 트리와는 별개로 동작
      - 브라우저는 이러한 각각의 별도의 DOM 트리를 렌더링하고, 이벤트를 처리하며, 변경사항을 추적해야 함
    - Shadow DOM은 모든 웹 브라우저에서 지원되지 않음
  - 구현 과제의 특성상 간단한 페이지 위주이기에 shadow dom의 단점에서 언급한 성능 부분에서의 문제는 미미할 것이라고 판단하여 코드 가독성과 유지보수 등의 이유로 선택

---
### 24.01.27
router 부분 문제 해결
- shadow dom을 사용하여 router를 구현할 경우 custom element 재정의 문제 발생
  - 페이지 별로 태그를 만들어서 중복 문제 해결

---
### 24.01.31 ~ 24.02.01
이벤트 처리 개선
- 사용자가 직접 id를 부여하고, 해당 element를 찾아 이벤트 리스너를 등록하는 것이 아닌, 속성으로 처리할 수 있게 변경
  - 이벤트 위임 활용
  - 컴포넌트가 렌더링 될 때 마다 이벤트 리스너가 제거되고, 등록되도록 구현
    - 처음 한번만 이벤트 리스너를 등록하면 구현이 간단하고, 작은 어플리케이션에서는 효율적일 수 있으나 자유롭지 못함

---
### 24.02.01
렌더링 최적화
- requestAnimationFrame을 활용하여 렌더링 최적화 수행
  - 모든 상태 등의 변화에 대해 렌더링을 수행할 경우 짧은 시간 내에 다수의 reflow, repaint가 발생할 가능성이 존재
    - 사람들은 이를 의식할 수 없어 비효율적이며, 에러를 유발할 수 있음
  - requestAnimationFrame 함수는 모니터 주사율에 따라 실행되는 함수
    - 60hz 모니터의 경우 1초에 60번, 144hz 모니터의 경우 1초에 144번 실행
  - 따라서 상태 등의 변화를 requestAnimationFrame 함수를 이용하여 변경
    - 짧은 시간 내에 다수의 작업이 발생하더라도, 특정 주기로 이를 반영하도록 하여 최적화 수행

---
### 24.08.16
shadow dom -> custom element로 변경
beforeMount, mounted, beforeUpdate, updated 메서드 추가, 라이프 사이클에 반영
